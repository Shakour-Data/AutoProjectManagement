"""
Comprehensive unit tests for autoprojectmanagement/api/server.py
Generated by AutoProjectManagement testing framework
"""

import pytest
import sys
import os
import json
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock, AsyncMock
import argparse
import signal

# Add source to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent.parent / "src"))

from autoprojectmanagement.api.server import (
    ServerManager, 
    load_configuration, 
    start_server, 
    signal_handler,
    DEFAULT_HOST,
    DEFAULT_PORT,
    DEFAULT_RELOAD,
    DEFAULT_LOG_LEVEL,
    DEFAULT_WORKERS,
    DEFAULT_TIMEOUT
)

@pytest.fixture
def server_manager():
    """Fixture for ServerManager instance with default configuration."""
    return ServerManager()

@pytest.fixture
def temp_config_file():
    """Fixture for temporary configuration file."""
    config_data = {
        "host": "0.0.0.0",
        "port": 9000,
        "reload": False,
        "log_level": "debug",
        "workers": 2,
        "timeout": 60
    }
    
    # Create a temporary file that persists for the test
    fd, temp_path = tempfile.mkstemp(suffix='.json')
    try:
        with os.fdopen(fd, 'w') as f:
            json.dump(config_data, f)
        yield temp_path
    finally:
        try:
            os.unlink(temp_path)
        except:
            pass

class TestServerManagerFunctionality:
    """Test class for ServerManager functionality tests"""
    
    def test_server_manager_initialization_defaults(self):
        """Test ServerManager initialization with default parameters."""
        manager = ServerManager()
        
        assert manager.host == DEFAULT_HOST
        assert manager.port == DEFAULT_PORT
        assert manager.reload == DEFAULT_RELOAD
        assert manager.log_level == DEFAULT_LOG_LEVEL
        assert manager.workers == DEFAULT_WORKERS
        assert manager.timeout == DEFAULT_TIMEOUT
        assert manager.running == False

    def test_server_manager_initialization_custom_params(self):
        """Test ServerManager initialization with custom parameters."""
        manager = ServerManager(
            host="0.0.0.0",
            port=9000,
            reload=False,
            log_level="debug",
            workers=4,
            timeout=45
        )
        
        assert manager.host == "0.0.0.0"
        assert manager.port == 9000
        assert manager.reload == False
        assert manager.log_level == "debug"
        assert manager.workers == 4
        assert manager.timeout == 45

    def test_server_manager_get_config(self):
        """Test getting server configuration."""
        manager = ServerManager(
            host="192.168.1.100",
            port=8080,
            reload=False,
            log_level="warning",
            workers=3,
            timeout=20
        )
        
        config = manager.get_config()
        
        assert config["host"] == "192.168.1.100"
        assert config["port"] == 8080
        assert config["reload"] == False
        assert config["log_level"] == "warning"
        assert config["workers"] == 3
        assert config["timeout"] == 20
        assert config["running"] == False

    def test_server_manager_health_check_running(self):
        """Test health check when server is running."""
        manager = ServerManager()
        manager.running = True
        
        health = manager.health_check()
        
        assert health["status"] == "healthy"
        assert health["host"] == DEFAULT_HOST
        assert health["port"] == DEFAULT_PORT
        assert "timestamp" in health

    def test_server_manager_health_check_stopped(self):
        """Test health check when server is stopped."""
        manager = ServerManager()
        manager.running = False
        
        health = manager.health_check()
        
        assert health["status"] == "stopped"
        assert health["host"] == DEFAULT_HOST
        assert health["port"] == DEFAULT_PORT

class TestServerManagerEdgeCases:
    """Test class for ServerManager edge cases"""
    
    def test_server_manager_min_port_number(self):
        """Test ServerManager with minimum valid port number."""
        manager = ServerManager(port=1)
        assert manager.port == 1

    def test_server_manager_max_port_number(self):
        """Test ServerManager with maximum valid port number."""
        manager = ServerManager(port=65535)
        assert manager.port == 65535

    def test_server_manager_zero_workers(self):
        """Test ServerManager with zero workers (edge case)."""
        manager = ServerManager(workers=0)
        assert manager.workers == 0

    def test_server_manager_high_timeout(self):
        """Test ServerManager with very high timeout value."""
        manager = ServerManager(timeout=3600)  # 1 hour
        assert manager.timeout == 3600

    def test_server_manager_special_host_addresses(self):
        """Test ServerManager with special host addresses."""
        test_cases = [
            "0.0.0.0",      # All interfaces
            "localhost",     # Localhost
            "127.0.0.1",     # Loopback
            "::1",           # IPv6 loopback
        ]
        
        for host in test_cases:
            manager = ServerManager(host=host)
            assert manager.host == host

class TestServerManagerErrorHandling:
    """Test class for ServerManager error handling"""
    
    @patch('autoprojectmanagement.api.server.uvicorn', None)
    def test_server_start_without_uvicorn(self):
        """Test server start when uvicorn is not available."""
        manager = ServerManager()
        manager.start()  # Should not raise exception
        
        # Should handle missing uvicorn gracefully
        assert True  # Test passes if no exception is raised

    def test_server_stop_when_not_running(self):
        """Test stopping server when it's not running."""
        manager = ServerManager()
        manager.running = False
        
        # Should not raise any exception
        manager.stop()
        assert manager.running == False

    @patch('autoprojectmanagement.api.server.logger')
    def test_server_start_logs_configuration(self, mock_logger):
        """Test that server start logs configuration properly."""
        manager = ServerManager(
            host="0.0.0.0",
            port=9000,
            reload=True,
            log_level="debug",
            workers=2,
            timeout=30
        )
        
        with patch('autoprojectmanagement.api.server.uvicorn') as mock_uvicorn:
            mock_uvicorn.run.side_effect = KeyboardInterrupt()
            manager.start()
        
        # Verify configuration was logged
        assert mock_logger.info.call_count >= 5  # At least 5 info logs

    @patch('autoprojectmanagement.api.server.uvicorn')
    def test_server_start_keyboard_interrupt(self, mock_uvicorn):
        """Test server handling of keyboard interrupt."""
        mock_uvicorn.run.side_effect = KeyboardInterrupt()
        
        manager = ServerManager()
        manager.start()  # Should handle KeyboardInterrupt gracefully
        
        assert mock_uvicorn.run.called

    @patch('autoprojectmanagement.api.server.uvicorn')
    def test_server_start_general_exception(self, mock_uvicorn):
        """Test server handling of general exceptions."""
        mock_uvicorn.run.side_effect = Exception("Server error")
        
        manager = ServerManager()
        
        with pytest.raises(Exception, match="Server error"):
            manager.start()

class TestServerManagerIntegration:
    """Test class for ServerManager integration tests"""
    
    @patch('autoprojectmanagement.api.server.uvicorn')
    def test_server_integration_with_uvicorn(self, mock_uvicorn):
        """Test integration with uvicorn server."""
        manager = ServerManager(
            host="0.0.0.0",
            port=8000,
            reload=True,
            log_level="info",
            workers=1,
            timeout=30
        )
        
        manager.start()
        
        # Verify uvicorn.run was called with correct parameters
        mock_uvicorn.run.assert_called_once_with(
            "autoprojectmanagement.api.app:app",
            host="0.0.0.0",
            port=8000,
            reload=True,
            log_level="info",
            workers=1,
            timeout_keep_alive=30
        )

    def test_server_configuration_persistence(self):
        """Test that server configuration persists through operations."""
        manager = ServerManager(
            host="192.168.1.100",
            port=8080,
            reload=False,
            log_level="warning",
            workers=3,
            timeout=45
        )
        
        # Perform multiple operations
        config1 = manager.get_config()
        manager.running = True
        health = manager.health_check()
        config2 = manager.get_config()
        manager.stop()
        config3 = manager.get_config()
        
        # Configuration should remain consistent
        assert config1["host"] == config2["host"] == config3["host"] == "192.168.1.100"
        assert config1["port"] == config2["port"] == config3["port"] == 8080
        assert config1["reload"] == config2["reload"] == config3["reload"] == False
        assert config1["log_level"] == config2["log_level"] == config3["log_level"] == "warning"
        assert config1["workers"] == config2["workers"] == config3["workers"] == 3
        assert config1["timeout"] == config2["timeout"] == config3["timeout"] == 45
        
        # Only running status should change
        assert config1["running"] == False
        assert config2["running"] == True
        assert config3["running"] == False

    @patch('autoprojectmanagement.api.server.uvicorn')
    def test_server_lifecycle_integration(self, mock_uvicorn):
        """Test complete server lifecycle integration."""
        manager = ServerManager()
        
        # Start server
        manager.start()
        assert mock_uvicorn.run.called
        
        # Stop server
        manager.stop()
        assert manager.running == False

    def test_server_with_mock_app_integration(self):
        """Test server integration with mock app (when uvicorn not available)."""
        with patch('autoprojectmanagement.api.server.uvicorn', None):
            manager = ServerManager()
            manager.start()  # Should handle missing uvicorn gracefully

    def test_server_configuration_validation_integration(self):
        """Test integration of configuration validation."""
        manager = ServerManager(
            host="localhost",
            port=3000,
            reload=True,
            log_level="debug",
            workers=2,
            timeout=15
        )
        
        config = manager.get_config()
        health = manager.health_check()
        
        # Configuration should be consistent across methods
        assert config["host"] == health["host"] == "localhost"
        assert config["port"] == health["port"] == 3000

class TestConfigurationLoading:
    """Test class for configuration loading functionality"""
    
    def test_load_configuration_defaults(self):
        """Test loading configuration with default values."""
        config = load_configuration()
        
        assert config["host"] == DEFAULT_HOST
        assert config["port"] == DEFAULT_PORT
        assert config["reload"] == DEFAULT_RELOAD
        assert config["log_level"] == DEFAULT_LOG_LEVEL
        assert config["workers"] == DEFAULT_WORKERS
        assert config["timeout"] == DEFAULT_TIMEOUT

    def test_load_configuration_from_env_vars(self):
        """Test loading configuration from environment variables."""
        env_vars = {
            "API_HOST": "192.168.1.50",
            "API_PORT": "9090",
            "API_RELOAD": "false",
            "API_LOG_LEVEL": "error",
            "API_WORKERS": "4",
            "API_TIMEOUT": "120"
        }
        
        with patch.dict('os.environ', env_vars):
            config = load_configuration()
            
            assert config["host"] == "192.168.1.50"
            assert config["port"] == 9090
            assert config["reload"] == False
            assert config["log_level"] == "error"
            assert config["workers"] == 4
            assert config["timeout"] == 120

    def test_load_configuration_from_file(self, temp_config_file):
        """Test loading configuration from file."""
        config = load_configuration(temp_config_file)
        
        assert config["host"] == "0.0.0.0"
        assert config["port"] == 9000
        assert config["reload"] == False
        assert config["log_level"] == "debug"
        assert config["workers"] == 2
        assert config["timeout"] == 60

    def test_load_configuration_file_priority(self, temp_config_file):
        """Test that file configuration takes priority over env vars."""
        env_vars = {
            "API_HOST": "192.168.1.50",
            "API_PORT": "9090"
        }
        
        with patch.dict('os.environ', env_vars):
            config = load_configuration(temp_config_file)
            
            # File config should override env vars
            assert config["host"] == "0.0.0.0"  # From file
            assert config["port"] == 9000       # From file
            assert config["reload"] == False    # From file

    def test_load_configuration_invalid_file(self):
        """Test loading configuration from invalid file."""
        config = load_configuration("/invalid/path/config.json")
        
        # Should fall back to defaults/env vars
        assert config["host"] == DEFAULT_HOST
        assert config["port"] == DEFAULT_PORT

class TestSignalHandling:
    """Test class for signal handling functionality"""
    
    @patch('autoprojectmanagement.api.server.logger')
    @patch('autoprojectmanagement.api.server.sys')
    def test_signal_handler(self, mock_sys, mock_logger):
        """Test signal handler functionality."""
        signal_handler(signal.SIGINT, None)
        
        mock_logger.info.assert_called_once()
        mock_sys.exit.assert_called_once_with(0)

class TestStartServerFunction:
    """Test class for start_server function"""
    
    @patch('autoprojectmanagement.api.server.ServerManager')
    def test_start_server_with_defaults(self, mock_server_manager):
        """Test start_server function with default parameters."""
        mock_manager = Mock()
        mock_server_manager.return_value = mock_manager
        
        start_server()
        
        mock_server_manager.assert_called_once_with(
            host=DEFAULT_HOST,
            port=DEFAULT_PORT,
            reload=DEFAULT_RELOAD,
            log_level=DEFAULT_LOG_LEVEL,
            workers=DEFAULT_WORKERS,
            timeout=DEFAULT_TIMEOUT
        )
        mock_manager.start.assert_called_once()

    @patch('autoprojectmanagement.api.server.ServerManager')
    def test_start_server_with_custom_params(self, mock_server_manager):
        """Test start_server function with custom parameters."""
        mock_manager = Mock()
        mock_server_manager.return_value = mock_manager
        
        start_server(
            host="0.0.0.0",
            port=9000,
            reload=False,
            log_level="debug",
            workers=2,
            timeout=60
        )
        
        mock_server_manager.assert_called_once_with(
            host="0.0.0.0",
            port=9000,
            reload=False,
            log_level="debug",
            workers=2,
            timeout=60
        )

    @patch('autoprojectmanagement.api.server.load_configuration')
    @patch('autoprojectmanagement.api.server.ServerManager')
    def test_start_server_with_config_file(self, mock_server_manager, mock_load_config):
        """Test start_server function with configuration file."""
        mock_load_config.return_value = {
            "host": "192.168.1.100",
            "port": 8080,
            "reload": False,
            "log_level": "warning",
            "workers": 3,
            "timeout": 45
        }
        
        mock_manager = Mock()
        mock_server_manager.return_value = mock_manager
        
        start_server(config_path="config.json")
        
        mock_server_manager.assert_called_once_with(
            host="192.168.1.100",
            port=8080,
            reload=False,
            log_level="warning",
            workers=3,
            timeout=45
        )

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
