"""
Comprehensive unit tests for autoprojectmanagement/api/realtime_service.py
Generated by AutoProjectManagement testing framework
"""

import pytest
import asyncio
import json
import time
from unittest.mock import Mock, patch, AsyncMock
import sys
from pathlib import Path

# Add source to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from autoprojectmanagement.api.realtime_service import EventService, Event, EventType, Connection

@pytest.fixture
def event_service():
    """Fixture for the EventService instance."""
    service = EventService()
    return service

@pytest.fixture
def connection():
    """Fixture for a Connection instance."""
    return Connection(connection_id="test_connection")

class TestEventService:
    """Test class for EventService functionality"""
    
    @pytest.mark.asyncio
    async def test_event_service_start_stop(self, event_service):
        """Test that the event service starts and stops correctly."""
        await event_service.start()
        assert event_service.running is True
        
        await event_service.stop()
        assert event_service.running is False

    @pytest.mark.asyncio
    async def test_event_service_register_connection(self, event_service, connection):
        """Test registering a new connection."""
        await event_service.start()
        connection_id = await event_service.register_connection(connection)
        assert connection_id == connection.connection_id
        assert connection.connection_id in event_service.connections

    @pytest.mark.asyncio
    async def test_event_service_unregister_connection(self, event_service, connection):
        """Test unregistering a connection."""
        await event_service.start()
        await event_service.register_connection(connection)
        await event_service.unregister_connection(connection.connection_id)
        assert connection.connection_id not in event_service.connections

    @pytest.mark.asyncio
    async def test_event_service_publish_event(self, event_service):
        """Test publishing an event."""
        await event_service.start()
        event = Event(type=EventType.FILE_CHANGE, data={"file_path": "test.txt"})
        await event_service.publish_event(event)
        assert len(event_service.recent_events) > 0

    @pytest.mark.asyncio
    async def test_event_service_subscribe_unsubscribe(self, event_service, connection):
        """Test subscribing and unsubscribing from events."""
        await event_service.start()
        await event_service.register_connection(connection)
        
        event_type = EventType.FILE_CHANGE
        event_service.subscribe(connection.connection_id, event_type)
        assert connection.is_subscribed(event_type)
        
        event_service.unsubscribe(connection.connection_id, event_type)
        assert not connection.is_subscribed(event_type)

    @pytest.mark.asyncio
    async def test_event_service_get_missed_events(self, event_service):
        """Test getting missed events."""
        await event_service.start()
        event = Event(type=EventType.FILE_CHANGE, data={"file_path": "test.txt"})
        await event_service.publish_event(event)
        
        # Should return no missed events since we just published
        missed_events = await event_service.get_missed_events(event.event_id)
        assert len(missed_events) == 0

    @pytest.mark.asyncio
    async def test_event_service_set_project_filter(self, event_service, connection):
        """Test setting project filter for connection."""
        await event_service.start()
        await event_service.register_connection(connection)
        
        project_id = "test_project_123"
        event_service.set_project_filter(connection.connection_id, project_id)
        assert connection.project_filter == project_id

    @pytest.mark.asyncio
    async def test_event_service_set_last_event_id(self, event_service, connection):
        """Test setting last event ID for connection."""
        await event_service.start()
        await event_service.register_connection(connection)
        
        event_id = "event_123"
        event_service.set_last_event_id(connection.connection_id, event_id)
        assert connection.last_event_id == event_id

    @pytest.mark.asyncio
    async def test_event_service_get_connection_stats(self, event_service, connection):
        """Test getting connection statistics."""
        await event_service.start()
        await event_service.register_connection(connection)
        
        stats = event_service.get_connection_stats()
        assert stats["total_connections"] == 1
        assert "subscription_counts" in stats
        assert "uptime_seconds" in stats

    @pytest.mark.asyncio
    async def test_event_service_register_event_handler(self, event_service):
        """Test registering event handlers."""
        async def test_handler(event):
            pass
            
        event_service.register_event_handler(EventType.FILE_CHANGE, test_handler)
        assert EventType.FILE_CHANGE in event_service.event_handlers
        assert len(event_service.event_handlers[EventType.FILE_CHANGE]) == 1

class TestEventServiceEdgeCases:
    """Test class for EventService edge cases"""
    
    @pytest.mark.asyncio
    async def test_event_service_publish_event_queue_full(self, event_service):
        """Test publishing event when queue is full."""
        await event_service.start()
        
        # Create a small queue to trigger timeout
        small_queue_service = EventService(max_queue_size=1)
        await small_queue_service.start()
        
        # Fill the queue
        event1 = Event(type=EventType.FILE_CHANGE, data={"file": "test1.txt"})
        await small_queue_service.publish_event(event1)
        
        # Try to publish another event (should timeout)
        event2 = Event(type=EventType.FILE_CHANGE, data={"file": "test2.txt"})
        await small_queue_service.publish_event(event2)  # Should not raise exception

    @pytest.mark.asyncio
    async def test_event_service_get_missed_events_not_found(self, event_service):
        """Test getting missed events when last event ID not found."""
        await event_service.start()
        
        # Publish some events
        event1 = Event(type=EventType.FILE_CHANGE, data={"file": "test1.txt"})
        await event_service.publish_event(event1)
        
        # Try to get missed events with non-existent event ID
        missed_events = await event_service.get_missed_events("non_existent_id")
        assert len(missed_events) == 0

    @pytest.mark.asyncio
    async def test_event_service_cleanup_inactive_connections(self, event_service, connection):
        """Test cleanup of inactive connections."""
        await event_service.start()
        await event_service.register_connection(connection)
        
        # Make connection inactive by setting old last_activity
        connection.last_activity = time.time() - 400  # 400 seconds ago
        
        # Test the cleanup logic directly without the infinite loop
        current_time = time.time()
        inactive_connections = []
        
        for connection_id, conn in list(event_service.connections.items()):
            if current_time - conn.last_activity > 1:  # 1 second timeout for test
                inactive_connections.append(connection_id)
        
        # Clean up inactive connections
        for connection_id in inactive_connections:
            await event_service.unregister_connection(connection_id)
        
        # Connection should be cleaned up
        assert connection.connection_id not in event_service.connections
        
        # Reset the connection for further tests
        await event_service.register_connection(connection)

    @pytest.mark.asyncio
    async def test_event_service_heartbeat_functionality(self, event_service):
        """Test heartbeat functionality."""
        await event_service.start()
        
        # Test heartbeat functionality directly without the infinite loop
        heartbeat_event = Event(
            type=EventType.HEALTH_CHECK,
            data={"message": "heartbeat", "timestamp": time.time()}
        )
        
        await event_service.publish_event(heartbeat_event)
        
        # Should have heartbeat events in recent events
        heartbeats = [e for e in event_service.recent_events if e.type == EventType.HEALTH_CHECK]
        assert len(heartbeats) > 0
        
        # Clean up the heartbeat events to avoid interference with other tests
        event_service.recent_events.clear()

class TestEventServiceErrorHandling:
    """Test class for EventService error handling"""
    
    @pytest.mark.asyncio
    async def test_event_service_publish_invalid_event(self, event_service):
        """Test publishing invalid event."""
        await event_service.start()
        
        # Should handle invalid event gracefully
        await event_service.publish_event(None)

    @pytest.mark.asyncio
    async def test_event_service_unregister_nonexistent_connection(self, event_service):
        """Test unregistering non-existent connection."""
        await event_service.start()
        
        # Should not raise error for non-existent connection
        await event_service.unregister_connection("non_existent_connection")

    @pytest.mark.asyncio
    async def test_event_service_subscribe_nonexistent_connection(self, event_service):
        """Test subscribing non-existent connection."""
        await event_service.start()
        
        # Should not raise error for non-existent connection
        event_service.subscribe("non_existent_connection", EventType.FILE_CHANGE)

class TestEventServiceIntegration:
    """Test class for EventService integration tests"""
    
    @pytest.mark.asyncio
    async def test_event_service_integration_with_utility_functions(self):
        """Test integration with utility functions."""
        # Use the global event service instance for integration tests
        from autoprojectmanagement.api.realtime_service import event_service
        
        await event_service.start()
        
        # Test publish_file_change_event utility function
        from autoprojectmanagement.api.realtime_service import publish_file_change_event
        await publish_file_change_event("test.txt", "modified", "test_project")
        
        # Should have file change event in recent events
        file_events = [e for e in event_service.recent_events if e.type == EventType.FILE_CHANGE]
        assert len(file_events) > 0

    @pytest.mark.asyncio
    async def test_event_service_integration_with_auto_commit_events(self):
        """Test integration with auto-commit events."""
        # Use the global event service instance for integration tests
        from autoprojectmanagement.api.realtime_service import event_service
        
        await event_service.start()
        
        # Test auto-commit utility functions
        from autoprojectmanagement.api.realtime_service import (
            publish_auto_commit_start,
            publish_auto_commit_result,
            publish_auto_commit_error
        )
        
        await publish_auto_commit_start("test_project", 5)
        await publish_auto_commit_result(True, 5, "Commit successful", "test_project")
        await publish_auto_commit_error("Commit failed", "test_project")
        
        # Should have auto-commit events in recent events
        auto_commit_events = [
            e for e in event_service.recent_events 
            if e.type in [EventType.AUTO_COMMIT_START, EventType.AUTO_COMMIT_RESULT, EventType.AUTO_COMMIT_ERROR]
        ]
        assert len(auto_commit_events) == 3

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
